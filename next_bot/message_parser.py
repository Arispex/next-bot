from __future__ import annotations

import re
from typing import Any

from nonebot.log import logger


def _message_segments_from_event(event: Any) -> list[Any]:
    original_message = getattr(event, "original_message", None)
    if original_message is None:
        return []
    try:
        return list(original_message)
    except TypeError:
        return []


def _segments_to_plain_text(segments: list[Any]) -> str:
    parts: list[str] = []
    for seg in segments:
        seg_type = getattr(seg, "type", "")
        data = getattr(seg, "data", {})
        if not isinstance(data, dict):
            data = {}

        if seg_type == "text":
            parts.append(str(data.get("text", "")))
            continue

        if seg_type == "at":
            qq = str(data.get("qq", "")).strip()
            if qq and qq != "all":
                # Keep spaces around converted qq so split() works reliably.
                parts.append(f" {qq} ")
            continue

    text = "".join(parts)
    # Normalize duplicated whitespace generated by mixed segments.
    return re.sub(r"\s+", " ", text).strip()


def parse_command_args(event: Any, command_name: str) -> list[str]:
    segments = _message_segments_from_event(event)
    if not segments:
        return []

    text = _segments_to_plain_text(segments)
    if not text:
        return []

    cmd = re.escape(command_name)
    match = re.match(rf"^/?{cmd}(?:\s+|$)", text)
    if match is None:
        return []

    args_text = text[match.end() :].strip()
    if not args_text:
        logger.info(f"消息解析器：command={command_name} text={text} args=[]")
        return []
    args = args_text.split()
    logger.info(f"消息解析器：command={command_name} text={text} args={args}")
    return args
