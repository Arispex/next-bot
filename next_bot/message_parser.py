from __future__ import annotations

import re
from typing import Any

from next_bot.db import User, get_session

from nonebot.log import logger


def _message_segments_from_event(event: Any) -> list[Any]:
    original_message = getattr(event, "original_message", None)
    if original_message is None:
        return []
    try:
        return list(original_message)
    except TypeError:
        return []


def _segments_to_plain_text(segments: list[Any]) -> str:
    parts: list[str] = []
    for seg in segments:
        seg_type = getattr(seg, "type", "")
        data = getattr(seg, "data", {})
        if not isinstance(data, dict):
            data = {}

        if seg_type == "text":
            parts.append(str(data.get("text", "")))
            continue

        if seg_type == "at":
            qq = str(data.get("qq", "")).strip()
            if qq and qq != "all":
                # Keep spaces around converted qq so split() works reliably.
                parts.append(f" {qq} ")
            continue

    text = "".join(parts)
    # Normalize duplicated whitespace generated by mixed segments.
    return re.sub(r"\s+", " ", text).strip()


def _extract_args_text(text: str, command_name: str) -> str | None:
    cmd = re.escape(command_name)
    match = re.match(rf"^/?{cmd}(?:\s+|$)", text)
    if match is None:
        return None
    return text[match.end() :].strip()


def parse_command_args(event: Any, command_name: str) -> list[str]:
    segments = _message_segments_from_event(event)
    if not segments:
        return []

    text = _segments_to_plain_text(segments)
    if not text:
        return []

    args_text = _extract_args_text(text, command_name)
    if args_text is None:
        return []

    if not args_text:
        logger.info(f"消息解析器：command={command_name} text={text} args=[]")
        return []
    args = args_text.split()
    logger.info(f"消息解析器：command={command_name} text={text} args={args}")
    return args


def parse_command_text(event: Any, command_name: str) -> str | None:
    segments = _message_segments_from_event(event)
    if not segments:
        return None

    text = _segments_to_plain_text(segments)
    if not text:
        return None

    args_text = _extract_args_text(text, command_name)
    if args_text is None:
        return None
    return args_text


def parse_command_args_with_fallback(
    event: Any, arg: Any, command_name: str
) -> list[str]:
    args = parse_command_args(event, command_name)
    if args:
        return args
    text = getattr(arg, "extract_plain_text", lambda: "")().strip()
    return [item for item in text.split() if item]


def parse_command_text_with_fallback(
    event: Any, arg: Any, command_name: str
) -> str:
    text = parse_command_text(event, command_name)
    if text is not None:
        return text
    return getattr(arg, "extract_plain_text", lambda: "")().strip()


def resolve_user_id_arg_with_fallback(
    event: Any,
    arg: Any,
    command_name: str,
    *,
    arg_index: int = 0,
) -> tuple[str | None, str | None]:
    args = parse_command_args_with_fallback(event, arg, command_name)
    if len(args) <= arg_index:
        return None, "missing"

    token = args[arg_index].strip()
    if not token:
        return None, "missing"

    # '@用户' 会在消息段解析中转换为纯数字 ID，这里与手输 ID 统一处理。
    if token.isdigit():
        return token, None

    session = get_session()
    try:
        matched = (
            session.query(User)
            .filter(User.name == token)
            .order_by(User.id.asc())
            .limit(2)
            .all()
        )
    finally:
        session.close()

    if not matched:
        logger.info(
            f"消息解析器：command={command_name} 用户参数解析失败 reason=name_not_found token={token}"
        )
        return None, "name_not_found"
    if len(matched) > 1:
        logger.info(
            f"消息解析器：command={command_name} 用户参数解析失败 reason=name_ambiguous token={token}"
        )
        return None, "name_ambiguous"

    resolved = str(matched[0].user_id).strip()
    logger.info(
        f"消息解析器：command={command_name} 用户参数解析成功 source=name token={token} user_id={resolved}"
    )
    return resolved, None
